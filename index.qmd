---
title: "Forecasting Unemployment rate using Bayesian VARs with Regime change"
author: "Nhu Minh Pham"

execute:
  echo: false
  
bibliography: references.bib
---

> **Abstract.** Research on how Bayesian VARs with regime change affect the forecasting 
of unemployment rate
>
> **Keywords.** bsvars, regime change, forecasting, R, 

# Introduction

The objective of this research project is to develop a Bayesian Vector Autoregression (BVAR) model incorporating regime changes to analyse the dynamic relationships among macroeconomic variables, assess their impact on the unemployment rate over different economic regimes through time-varying parameters, and enhance forecasting accuracy.

The question to be addressed in this research is: Can a Bayesian VAR model with regime changes accurately capture shifts in the relationships between unemployment rate and other macroeconomic variables for improved forecasting performance?

# Motivation
Understanding the impact of economic regime changes on the unemployment rate dynamics holds substantial importance in grasping the complexities of the labour market. The labour market is highly susceptible to various shocks and policy interventions, making accurate forecasting of the unemployment rate crucial for informed decision-making. By employing a Bayesian Vector Autoregression (BVAR) model that allows the parameters to vary across different economic regimes, we can gain a nuanced understanding of how the unemployment rate responds to diverse economic conditions and the efficacy of policies. This research enhances forecasting accuracy and offers valuable insights into the underlying drivers of unemployment fluctuations. By better understanding these dynamics, policymakers can make more informed decisions to counter economic instability.


# Data properties

For the investigation of the problem at hand, the selection of variables includes a comprehensive set of economic indicators and demographic factors that are crucial for understanding labour market dynamics and their impact on unemployment rates. 

For instance, GDP growth provides a broad measure of economic activity, serving as an indicator of overall labour market. Consumer price index, wage price index and interest rate reflect macroeconomic conditions and monetary policy, influencing consumer spending, business investment, and hiring decisions, thereby affecting unemployment trends. Government spending impacts aggregate demand and employment levels, while demographic factors such as population growth rate, average age of the workforce, and level of highest educational attainment offer insights into labour force participation and composition. 

Each variable's form/transformation will depend on its specific characteristics and the nature of its relationship with unemployment. For instance, variables like GDP growth may be included in their original form, while others, such as wpi might need to be computed from the index data. 

It's important to note that all data will be quarterly since the interest forecasting for unemployment will be conducted at a quarterly frequency. Quarterly frequency is suitable for capturing the diverse movements influencing unemployment, including short-term shocks, long-term trends, and policy changes, providing a balanced perspective.



\begin{align*}
& unmp_{t} & : & \text{Unemployment rate} \\
& par_{t} & : & \text{Participation rate} \\
& gdp_{t} & : & \text{GDP per capita: Chain volume measures} \\
& cpi_{t} & : & \text{Consumer price index} \\
& wage_{t} & : & \text{Real wages} \\
& cashrate_{t} & : & \text{Cash rate} \\
& hrfull_{t} & : & \text{Average hours worked Full time} \\
& hrpart_{t} & : & \text{Average hours worked Part time} \\
& oversea_{t} & : & \text{Oversea migration} \\
& pop_{t} & : & \text{Population growth rate} \\
\end{align*}

```{r}
# Set global options to hide the source code, messages, and warnings
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

# Data Visualisation
```{r, hide = TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(readrba)
library(readabs)
library(ggplot2)
library(xts)
library(tseries)
library(MSwM)
```



```{r,echo=FALSE, warning=FALSE, message=FALSE}
start_date <- as.Date("1991-03-01")
end_date <- as.Date("2023-12-01")

########################################
# Define a function to process ABS data
########################################
process_abs_data <- function(series_id, start_date, end_date) {
  # Read raw data from ABS
  abs_data <- read_abs(series_id = series_id)
  
  # Convert to xts object
  abs_xts <- xts(abs_data$value, order.by = as.Date(abs_data$date))
  
  # Check if data is already in quarterly frequency
  if (abs_data$frequency == "Quarterly") {
    # Data is already in quarterly frequency
    abs_quarterly <- abs_xts
  } else {
    # Aggregate to quarterly frequency
    abs_quarterly <- apply.quarterly(abs_xts, mean)
  }
  
  # Convert to dataframe
  abs_df <- data.frame(Date = index(abs_quarterly), Value = coredata(abs_quarterly))
  
  # Subset to specified date range
  abs_df <- abs_df[abs_df$Date >= start_date & abs_df$Date <= end_date, ]
  
  # Return the processed dataframe
  return(abs_df)
}

########################################
# Define a function to process RBA data
########################################
process_rba_data <- function(series_id, start_date, end_date) {
  # Read raw data from ABS
  rba_data <- read_rba(series_id = series_id)
  
  # Convert to xts object
  rba_xts <- xts(rba_data$value, order.by = as.Date(rba_data$date))
  
  # Check if data is already in quarterly frequency
  if (rba_data$frequency == "Quarterly") {
    # Data is already in quarterly frequency
    rba_quarterly <- rba_xts
  } else {
    # Aggregate to quarterly frequency
    rba_quarterly <- apply.quarterly(rba_xts, mean)
  }
  
  # Convert to dataframe
  rba_df <- data.frame(Date = index(rba_quarterly), Value = coredata(rba_quarterly))
  
  # Subset to specified date range
  rba_df <- rba_df[rba_df$Date >= start_date & rba_df$Date <= end_date, ]
  
  # Return the processed dataframe
  return(rba_df)
}

```



```{r,echo=FALSE, warning=FALSE, message=FALSE}

#### check flow and stock, stock = end of quarter, flow= sum up

# Unemployment rate ################## "6202.0", A84423130A trend, A84423046K seasonadj
unmp_df <- process_abs_data("A84423046K", start_date, end_date)

# Participation rate ################## "6202.0", A84423051C seasonadj
par_df <- process_abs_data("A84423051C", start_date, end_date)

# GDP per capita: Chain volume measures; ##### "5206.0", A2304404C seasonadj, old A2304372W
gdp_df <- process_abs_data("A2304404C", start_date, end_date)

# WPI, Total hourly rates of pay including bonuses ###### 6345.0, A2713849C seasonadj
wpi_df <- process_abs_data("A2713849C", start_date, end_date)

# CPI ################## 6401.0, A3604506F seasonadj
cpi_df <- process_abs_data("A3604506F", start_date, end_date)

# Cash rate ################## original
cashrate_df <- process_rba_data("FIRMMCRT", start_date, end_date)

# Monthly hours works - Full time. "6202.0", A84426278A seasonadj
hrs_full_df <- process_abs_data("A84426278A", start_date, end_date)

# Monthly hours works - Part time. "6202.0", A84426279C seasonadj
hrs_part_df <- process_abs_data("A84426279C", start_date, end_date)

# Net Overseas Migration ################## "3101.0",  A2133254C original
oversea_df <- process_abs_data("A2133254C", start_date, end_date)

# Population ############# "3101.0", A2060842F original
pop_df <- process_abs_data("A2060842F", start_date, end_date)
```


```{r, plot, echo=FALSE, fig.width=8, fig.height=6}
dataframes <- list(unmp_df = "Unemployment rate",
                    par_df = "Participation rate",
                    gdp_df = "GDP per capita",
                    wpi_df = "WPI",
                    cpi_df = "CPI",
                    cashrate_df = "Cash rate",
                    hrs_full_df = "Hours worked Full time",
                    hrs_part_df = "Hours worked Part time",
                    oversea_df = "Net Overseas Migration",
                    pop_df = "Population growth")

par(mfrow = c(3, 4))

for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- df$Value
  plot(df$Date, y_values, type = "l", 
       xlab = "Date", 
       ylab = "Value", 
       main = dataframes[[df_name]])
}



```
<div id="figure1" style="text-align: center; color: #696969;">
###### Figure 1: Time series plots
</div>

```{r}
# Log-transformation
log_dataframes <- c("gdp_df", "wpi_df", "cpi_df", "hrs_full_df", "hrs_part_df", "oversea_df", "pop_df")

# Log-transform the specified dataframes
for (df_name in log_dataframes) {
  df <- get(df_name)
  df$Value <- log(df$Value)  # Log-transform the 'Value' column
  assign(df_name, df)         # Assign the modified dataframe back to its original name
}

oversea_df <- na.omit(oversea_df)

```




```{r, echo=FALSE, fig.width=8, fig.height=6}

dataframes <- list(unmp_df = "Unemployment rate",
                    par_df = "Participation rate",
                    gdp_df = "GDP per capita",
                    wpi_df = "WPI",
                    cpi_df = "CPI",
                    cashrate_df = "Cash rate",
                    hrs_full_df = "Hours worked Full time",
                    hrs_part_df = "Hours worked Part time",
                    oversea_df = "Net Overseas Migration",
                    pop_df = "Population growth")

par(mfrow = c(3, 4))

for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- df$Value
  plot(df$Date, y_values, type = "l", 
       xlab = "Date", 
       ylab = "Value", 
       main = dataframes[[df_name]])
}
```
To stabilize the variance, log tranformation is performed on all variables except 
unemployment rate, participation rate and cash rate.

From the plot of the variables, some show stationary and some non-stationary, which can make it challenging to analyse data. Therefore, the ACF test is performed to identify patterns and trend.


```{r,echo=FALSE, fig.width=8, fig.height=6}
par(mfrow = c(3, 4))

# Loop through each dataframe and create ACF plot
for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- df$Value
  acf(y_values, plot = TRUE, na.action = na.pass, main = paste("ACF of",
                                                               dataframes[[df_name]]))
}
```
<div id="figure2" style="text-align: center; color: #696969;">
###### Figure 2: ACF plots
</div>

The ACF plots show the variables have persistence or dependence in the data as the they are slowly decaying, indicates that there is a strong correlation between each variable 
and its past values, though this auto correlations decrease as lags increase.

```{r,echo=FALSE, fig.width=8, fig.height=6}
par(mfrow = c(3, 4))

# Loop through each dataframe and create ACF plot
for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- df$Value
  pacf(y_values, plot = TRUE, na.action = na.pass, main = paste("PACF of",
                                                               dataframes[[df_name]]))
}
```
<div id="figure3" style="text-align: center; color: #696969;">
###### Figure 3: PACF plots
</div>

The PACF plots show high autocorrelation at lag 1, and have clear cut offs.

The ADF is performed to further determine the stationary properties of the data.
Null hypothesis: a unit root is present
Alternative hypothesis: stationary
```{r}
# Perform ADF test for each variable
dataframes <- list(unmp_df = "Unemployment rate",
                    par_df = "Participation rate",
                    gdp_df = "GDP per capita",
                    wpi_df = "WPI",
                    cpi_df = "CPI",
                    cashrate_df = "Cash rate",
                    hrs_full_df = "Hours worked Full time",
                    hrs_part_df = "Hours worked Part time",
                    oversea_df = "Net Overseas Migration",
                    pop_df = "Population growth")

# Create an empty dataframe to store ADF test results
adf <- data.frame(Dickey_Fuller = numeric(length(dataframes)), 
                  p_value = numeric(length(dataframes)))

# Set row names to variable names
rownames(adf) <- names(dataframes)

# Perform ADF test for each variable
for (i in 1:length(dataframes)) {
  df <- get(names(dataframes)[i])  # Get the dataframe corresponding to the current variable
  adf_tmp <- adf.test(df$Value)    # Perform ADF test on the 'Value' column of the dataframe
  adf[i, "Dickey_Fuller"] <- as.numeric(adf_tmp$statistic)
  adf[i, "p_value"] <- as.numeric(adf_tmp$p.value)
}

# Round the numeric values to desired precision
adf <- round(adf, 3)

# Print the ADF test results
print(adf)
```


## Model

### Hypothesis

Var(p) model
\begin{aligned}
y_t = \beta_0 + \beta_1 y_{t-1} + \beta_2 x_{1, t-1} + \beta_3 x_{2, t-1} + \ldots + \beta_n x_{n, t-1} + \varepsilon_t
\end{aligned}


Var(p) model with regime change, meaning time-varying parameters
\begin{aligned}
y_t &= \beta_{0,S_t} + \beta_{1,S_t} y_{t-1} + \beta_{2,S_t} x_{1, t-1} + \beta_{3,S_t} x_{2, t-1} + \ldots + \beta_{n,S_t} x_{n, t-1} + \varepsilon_t \\
\end{aligned}

Probability of transitioning from one state to another
\begin{aligned}
P(S_t = j | S_{t-1} = i) &= \pi_{ij}
\end{aligned}



### Matrix form


\begin{align*}
\mathbf{Y}_t = \boldsymbol{\beta}_{S_t} \mathbf{X}_t + \boldsymbol{E}_t
\end{align*}

\begin{align*}
\boldsymbol{E}_t
\sim MN(0_T, \Sigma, I_T)
\end{align*}

\\begin{align*}
\\mathbf{Y}_t & : \\text{Matrix of response variables} \\\\
\\boldsymbol{\\beta} & : \\text{Coefficient matrix corresponding to regime state} \\\\
S_t & : \\text{Regime state} \\\\
\\mathbf{X}_t & : \\text{Matrix of predictor variables} \\\\
\\boldsymbol{\\varepsilon}_t & : \\text{Error term vector} 
\\end{align*}

\\begin{align*}
\\mathbf{Y}_t = \\begin{pmatrix}
\\text{Unemployment}_t \\\\
\\text{Participation}_t \\\\
\\text{GDP}_t \\\\
\\text{WPI}_t \\\\
\\text{CPI}_t \\\\
\\text{CashRate}_t \\\\
\\text{HoursFull}_t \\\\
\\text{HoursPart}_t \\\\
\\text{OverseasMigration}_t \\\\
\\text{Population}_t \\\\
\\end{pmatrix}
\\end{align*}

The model's equations include time-varying parameters, such as the coefficients of lagged variables, which adapt to changing economic conditions.

## Basic Model
The model follows the Normal Inverse Wishart distribution.

### Prior distribution

The Minnesota prior is commonly used in Bayesian Vector Autoregression (BVAR) models due to its ability to impose shrinkage towards zero on the coefficients, effectively regularizing the estimation process. The Minnesota prior aligns effectively with the stylized fact of nonstationarity observed in macroeconomic variables.

\begin{align*}
p(A, \Sigma) = p(A \mid \Sigma) \cdot p(\Sigma) \\
A \mid \Sigma \sim \text{MN}_{K \times N} (\underline{A}, \Sigma, \underline{V}) \\
\Sigma \sim  \text{IW}_{N} (\underline{S}, \underline{v})\\
\end{align*}

With lags = 2 and N = 4

\begin{align*}
\underline{A} = \begin{bmatrix}
\mathbf{0}_{4 \times 1} & \mathbf{I}_{4} & \mathbf{0}_{4 \times (2-1)4}
\end{bmatrix}
= \begin{bmatrix}
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\
\end{bmatrix}
\end{align*}

The column-specific prior covariance of A
\begin{align*}
\underline{V} &= \text{diag}\left( \begin{bmatrix}
k_2 & k_1(\mathbf{p}^{-2} \otimes 1'_4)
\end{bmatrix} \right)\\
\mathbf{p} &= \begin{bmatrix}
1 & 2 & \cdots & p \\
\end{bmatrix}
\end{align*}
\begin{align*}
& k_2 : \text{overall shrinkage for the constant term} \\
& k_1 : \text{overall shrinkage levels for autoregressive slopes} \\
\end{align*}

Prior covariance matrix
\begin{bmatrix}
k_2 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & \frac{k_1}{\sigma_1^{2}} & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & \frac{k_1}{\sigma_1^{2}} & 0 & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & \frac{k_1}{\sigma_1^{2}} & 0 & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & \frac{k_1}{\sigma_1^{2}} & 0 & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & \frac{k_1}{4\sigma_1^{2}} & 0 & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & \frac{k_1}{4\sigma_1^{2}} & 0 & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & \frac{k_1}{4\sigma_1^{2}} & 0 \\
0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & \frac{k_1}{4\sigma_1^{2}} \\
\end{bmatrix}


The joint posterior distribution

\begin{align*}
p(A, \Sigma) &= p(A \mid \Sigma) \cdot p(\Sigma) \\
A \mid \Sigma &\sim \text{MN}_{K \times N} (\underline{A}, \Sigma, \underline{V}) \\
\Sigma &\sim \text{IW}_{N} (\underline{S}, \underline{v})\\
\end{align*}


\begin{align}
p(A,\Sigma | Y,X) &= p(A|Y,X,\Sigma)p(\Sigma|Y,X) \\
p(A|Y,X,\Sigma) &\sim MN_{K \times N}(\overline{A}, \Sigma,\overline{V} ) \\ 
p(\Sigma|Y,X) &\sim IW_{N}(\overline{S}, \overline{v})\\
\\
\overline{V} &= (X'X + \underline{V}^{-1})^{-1} \\
\overline{A} &= \overline{V}(X'Y+\underline{V}^{-1}\underline{A}) \\
\overline{v} &= T + \underline{v} \\ 
\overline{S} &= \underline{S}+Y'Y+\underline{A}'\underline{V}^{-1}\underline{A}-\overline{A}'
\overline{V}^{-1}\overline{A} \\
\end{align}

```{r}

```


```{r}
# Need Model
# Need number of regime states -> AIC,BIC? No need, r=2
# dummy obse prior+minnesota, 2021, 2016

# state 2
# Need lag
# To estimate S, How do i want to model St
# Mackov switching or assume S



# Find number of regime states
# mod.mswm <- msmFit(mod,k=2,p=0,sw=c(TRUE,TRUE),control=list(parallel=TRUE))

```



# References {.unnumbered}