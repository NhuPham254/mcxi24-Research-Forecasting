---
title: "Forecasting Unemployment rate using Bayesian VARs with Regime change"
author: "Nhu Minh Pham"

execute:
  echo: false
  
bibliography: references.bib
---

> **Abstract.** Research on how Bayesian VARs with regime change affect the forecasting 
of unemployment rate
>
> **Keywords.** bsvars, regime change, forecasting, R, 

# Introduction

The objective of this research project is to develop a Bayesian Vector Autoregression (BVAR) model incorporating regime changes to analyse the dynamic relationships among macroeconomic variables, assess their impact on the unemployment rate over different economic regimes through time-varying parameters, and enhance forecasting accuracy.

The question to be addressed in this research is: Can a Bayesian VAR model with regime changes accurately capture shifts in the relationships between unemployment rate and other macroeconomic variables for improved forecasting performance?

# Motivation
Understanding the impact of economic regime changes on the unemployment rate dynamics holds substantial importance in grasping the complexities of the labour market. The labour market is highly susceptible to various shocks and policy interventions, making accurate forecasting of the unemployment rate crucial for informed decision-making. By employing a Bayesian Vector Autoregression (BVAR) model that allows the parameters to vary across different economic regimes, we can gain a nuanced understanding of how the unemployment rate responds to diverse economic conditions and the efficacy of policies. This research enhances forecasting accuracy and offers valuable insights into the underlying drivers of unemployment fluctuations. By better understanding these dynamics, policymakers can make more informed decisions to counter economic instability.


# Data properties

For the investigation of the problem at hand, the selection of variables includes a comprehensive set of economic indicators and demographic factors that are crucial for understanding labour market dynamics and their impact on unemployment rates. 

For instance, GDP growth provides a broad measure of economic activity, serving as an indicator of overall labour market. Consumer price index, wage price index and interest rate reflect macroeconomic conditions and monetary policy, influencing consumer spending, business investment, and hiring decisions, thereby affecting unemployment trends. Government spending impacts aggregate demand and employment levels, while demographic factors such as population growth rate, average age of the workforce, and level of highest educational attainment offer insights into labour force participation and composition. 

Each variable's form/transformation will depend on its specific characteristics and the nature of its relationship with unemployment. For instance, variables like GDP growth may be included in their original form, while others, such as wpi might need to be computed from the index data. 

It's important to note that all data will be quarterly since the interest forecasting for unemployment will be conducted at a quarterly frequency. Quarterly frequency is suitable for capturing the diverse movements influencing unemployment, including short-term shocks, long-term trends, and policy changes, providing a balanced perspective.



\begin{align*}
& unmp_{t} & : & \text{Unemployment rate} \\
& par_{t} & : & \text{Participation rate} \\
& gdp_{t} & : & \text{GDP per capita: Chain volume measures - Percentage changes} \\
& cpi_{t} & : & \text{Consumer price index} \\
& wpi_{t} & : & \text{Wage price index} \\
& cashrate_{t} & : & \text{Cash rate} \\
& hrfull_{t} & : & \text{Average hours worked Full time} \\
& hrpart_{t} & : & \text{Average hours worked Part time} \\
& oversea_{t} & : & \text{Oversea migration} \\
& pop_{t} & : & \text{Population growth rate} \\
\end{align*}

```{r}
# Set global options to hide the source code, messages, and warnings
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

# Data Visualisation
```{r, hide = TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(readrba)
library(readabs)
library(ggplot2)
library(tsibble)
library(xts)
```

```{r,echo=FALSE, warning=FALSE, message=FALSE}
start_date <- as.Date("1991-03-01")
end_date <- as.Date("2023-12-01")

########################################
# Define a function to process ABS data
########################################
process_abs_data <- function(series_id, start_date, end_date) {
  # Read raw data from ABS
  abs_data <- read_abs(series_id = series_id)
  
  # Convert to xts object
  abs_xts <- xts(abs_data$value, order.by = as.Date(abs_data$date))
  
  # Check if data is already in quarterly frequency
  if (abs_data$frequency == "Quarterly") {
    # Data is already in quarterly frequency
    abs_quarterly <- abs_xts
  } else {
    # Aggregate to quarterly frequency
    abs_quarterly <- apply.quarterly(abs_xts, mean)
  }
  
  # Convert to dataframe
  abs_df <- data.frame(Date = index(abs_quarterly),
                       Value = coredata(abs_quarterly))
  
  # Subset to specified date range
  abs_df <- abs_df[abs_df$Date >= start_date & abs_df$Date <= end_date, ]
  
  # Return the processed dataframe
  return(abs_df)
}

########################################
# Define a function to process RBA data
########################################
process_rba_data <- function(series_id, start_date, end_date) {
  # Read raw data from ABS
  rba_data <- read_rba(series_id = series_id)
  
  # Convert to xts object
  rba_xts <- xts(rba_data$value, order.by = as.Date(rba_data$date))
  
  # Check if data is already in quarterly frequency
  if (rba_data$frequency == "Quarterly") {
    # Data is already in quarterly frequency
    rba_quarterly <- rba_xts
  } else {
    # Aggregate to quarterly frequency
    rba_quarterly <- apply.quarterly(rba_xts, mean)
  }
  
  # Convert to dataframe
  rba_df <- data.frame(Date = index(rba_quarterly),
                       Value = coredata(rba_quarterly))
  
  # Subset to specified date range
  rba_df <- rba_df[rba_df$Date >= start_date & rba_df$Date <= end_date, ]
  
  # Return the processed dataframe
  return(rba_df)
}

```


```{r,echo=FALSE, warning=FALSE, message=FALSE}

# Unemployment rate ################## "6202.0", tables = 37
unmp_df <- process_abs_data("A84423130A", start_date, end_date)

# Participation rate
par_df <- process_abs_data("A84423051C", start_date, end_date)

# GDP ################## 5206.0
gdp_df <- process_abs_data("A2304372W", start_date, end_date)

# WPI ################## 6345.0
wpi_df <- process_abs_data("A2615579C", start_date, end_date)
# Calculate percentage change
percentage_change <- c(NA, diff(wpi_df$Value) / lag(wpi_df$Value, default = 1) * 100)
# Assign the percentage_change vector to the dataset
wpi_df$percentage_change <- percentage_change[1:nrow(wpi_df)]

# CPI ################## 6401.0
cpi_df <- process_abs_data("A2325850V", start_date, end_date)

# Interest rate ##################
cashrate_df <- process_rba_data("FIRMMCRT", start_date, end_date)

# Monthly hours works - Full time. "6202.0"
hrs_full_df <- process_abs_data("A84426278A", start_date, end_date)

# Monthly hours works - Part time. "6202.0"
hrs_part_df <- process_abs_data("A84426279C", start_date, end_date)

# Net Overseas Migration
oversea_df <- process_abs_data("A2133254C", start_date, end_date)

# Population growth rate
pop_df <- process_abs_data("A2133256J", start_date, end_date)
```


```{r, plot, echo=FALSE, fig.width=8, fig.height=6}
dataframes <- list(unmp_df = "Unemployment rate",
                    par_df = "Participation rate",
                    gdp_df = "GDP per capita",
                    wpi_df = "WPI",
                    cpi_df = "CPI",
                    cashrate_df = "Cash rate",
                    hrs_full_df = "Hours worked Full time",
                    hrs_part_df = "Hours worked Part time",
                    oversea_df = "Net Overseas Migration",
                    pop_df = "Population growth")

par(mfrow = c(3, 4))

for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- if (df_name == "wpi_df") df$percentage_change else df$Value
  plot(df$Date, y_values, type = "l", 
       xlab = "Date", 
       ylab = if (df_name == "wpi") "Percentage Change" else "Value", 
       main = dataframes[[df_name]])
}

```
<div id="figure1" style="text-align: center; color: #696969;">
###### Figure 1: Time series plots
</div>

From the plot of the variables, they all show non-stationary, which can make it challanging 
to analyse data. Therefore, the ACF test is performed to identify patterns and trend.


```{r,echo=FALSE, fig.width=8, fig.height=6}
par(mfrow = c(3, 4))

# Loop through each dataframe and create ACF plot
for (df_name in names(dataframes)) {
  df <- get(df_name)
  y_values <- if (df_name == "wpi_df") df$percentage_change else df$Value
  acf(y_values, plot = TRUE, na.action = na.pass, main = paste("ACF of",
                                                               dataframes[[df_name]]))
}
```
<div id="figure2" style="text-align: center; color: #696969;">
###### Figure 2: ACF plots
</div>

The ACF plots show the variables have high memory pattern, indicates that there is a strong correlation between each variable and its past values, suggesting persistence or dependence over time.

## Model

### Hypothesis

Var(p) model
\begin{aligned}
y_t = \beta_0 + \beta_1 y_{t-1} + \beta_2 x_{1, t-1} + \beta_3 x_{2, t-1} + \ldots + \beta_n x_{n, t-1} + \varepsilon_t
\end{aligned}


Var(p) model with regime change, meaning time-varying parameters
\begin{aligned}
y_t &= \beta_{0,S_t} + \beta_{1,S_t} y_{t-1} + \beta_{2,S_t} x_{1, t-1} + \beta_{3,S_t} x_{2, t-1} + \ldots + \beta_{n,S_t} x_{n, t-1} + \varepsilon_t \\
\end{aligned}

Probability of transitioning from one state to another
\begin{aligned}
P(S_t = j | S_{t-1} = i) &= \pi_{ij}
\end{aligned}



### Matrix form


\begin{align*}
\mathbf{Y}_t = \boldsymbol{\beta}_{S_t} \mathbf{X}_t + \boldsymbol{E}_t
\end{align*}

\begin{align*}
\boldsymbol{E}_t
\sim MN(0_T, \Sigma, I_T)
\end{align*}

\\begin{align*}
\\mathbf{Y}_t & : \\text{Matrix of response variables} \\\\
\\boldsymbol{\\beta} & : \\text{Coefficient matrix corresponding to regime state} \\\\
S_t & : \\text{Regime state} \\\\
\\mathbf{X}_t & : \\text{Matrix of predictor variables} \\\\
\\boldsymbol{\\varepsilon}_t & : \\text{Error term vector} 
\\end{align*}

The model's equations include time-varying parameters, such as the coefficients of lagged variables, which adapt to changing economic conditions.


# References {.unnumbered}